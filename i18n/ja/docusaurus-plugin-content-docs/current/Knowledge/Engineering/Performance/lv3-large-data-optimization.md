---
id: performance-lv3-large-data-optimization
title: '[Lv3] 大量データの最適化戦略：方式選択と実装'
slug: /experience/performance/lv3-large-data-optimization
tags: [Experience, Interview, Performance, Lv3]
---

> 画面に数万件のデータを表示する必要がある場合、パフォーマンス、ユーザー体験、開発コストのバランスをどう取るか？

## 面接シナリオ問題

**Q: 画面に数万件のデータがある場合、どのように最適化しますか？**

これはオープンな質問で、面接官が期待しているのは単一の解決策ではなく：

1. **要件評価**：本当に一度にこれだけのデータを表示する必要があるか？
2. **方式選択**：どんな方式があるか？各メリット・デメリットは？
3. **総合的な思考**：フロントエンド + バックエンド + UX の総合的な考慮
4. **実際の経験**：選択の理由と実施効果

---

## 第一歩：要件評価

技術方式を選ぶ前に、以下の質問を自分に問いかけます：

### コアな質問

```markdown
❓ ユーザーは本当に全データを見る必要があるか？
→ ほとんどの場合、ユーザーが気にするのは最初の 50-100 件
→ フィルタリング、検索、ソートで範囲を絞れる

❓ データはリアルタイム更新が必要か？
→ WebSocket リアルタイム更新 vs 定期ポーリング vs 初回読み込みのみ

❓ ユーザーの操作パターンは？
→ 閲覧メイン → 仮想スクロール
→ 特定データの検索 → 検索 + ページネーション
→ 1件ずつ確認 → 無限スクロール

❓ データ構造は固定か？
→ 高さ固定 → 仮想スクロールが実装しやすい
→ 高さ不定 → 動的高さ計算が必要

❓ 全選択、印刷、エクスポートが必要か？
→ 必要 → 仮想スクロールには制約あり
→ 不要 → 仮想スクロールが最適
```

### 実際のケース分析

```javascript
// ケース 1：取引履歴（10,000+ 件）
ユーザー行動：直近の取引を確認、たまに特定日付を検索
最適な方式：バックエンドページネーション + 検索

// ケース 2：リアルタイムゲームリスト（3,000+ 本）
ユーザー行動：閲覧、カテゴリフィルタリング、スムーズなスクロール
最適な方式：仮想スクロール + フロントエンドフィルタリング

// ケース 3：ソーシャルフィード（無限に増加）
ユーザー行動：下にスクロールし続ける、ページ切り替え不要
最適な方式：無限スクロール + バッチ読み込み

// ケース 4：データレポート（複雑なテーブル）
ユーザー行動：閲覧、ソート、エクスポート
最適な方式：バックエンドページネーション + エクスポート API
```

---

## 最適化方式の概要

### 方式比較表

| 方式             | 適用シーン             | メリット                 | デメリット               | 実装難度   | パフォーマンス |
| ---------------- | ---------------------- | ------------------------ | ------------------------ | ---------- | -------------- |
| **バックエンドページネーション** | ほとんどのシーン | シンプルで信頼性が高い、SEO 対応 | ページ切り替えが必要、体験の中断 | 1/5 簡単 | 3/5 中程度 |
| **仮想スクロール** | 大量の固定高さデータ | 最高のパフォーマンス、スムーズなスクロール | 実装が複雑、ネイティブ検索不可 | 4/5 複雑 | 5/5 最高 |
| **無限スクロール** | SNS、ニュースフィード | 連続的な体験、実装がシンプル | メモリ蓄積、ページジャンプ不可 | 2/5 簡単 | 3/5 中程度 |
| **データバッチ処理** | 初回読み込みの最適化 | プログレッシブ読み込み、スケルトンスクリーン対応 | バックエンドとの連携が必要 | 2/5 簡単 | 3/5 中程度 |
| **Web Worker**   | 大量計算、ソート、フィルタリング | メインスレッドをブロックしない | 通信オーバーヘッド、デバッグ困難 | 3/5 中程度 | 4/5 良好 |
| **ハイブリッド方式** | 複雑な要件         | 複数方式のメリットを組み合わせ | 複雑度が高い | 4/5 複雑 | 4/5 良好 |

---

## 方式の詳細

### 1. バックエンドページネーション（Pagination）— 第一選択

> **推奨度：5/5（強く推奨）**
> 最も一般的で信頼性の高い方式。80% のシーンに適合

#### 実装方法

```javascript
// フロントエンドリクエスト
async function fetchData(page = 1, pageSize = 20) {
  const response = await fetch(`/api/data?page=${page}&pageSize=${pageSize}`);
  return response.json();
}

// バックエンド API（Node.js + MongoDB の例）
app.get('/api/data', async (req, res) => {
  const page = parseInt(req.query.page) || 1;
  const pageSize = parseInt(req.query.pageSize) || 20;
  const skip = (page - 1) * pageSize;

  const data = await Collection.find().skip(skip).limit(pageSize).lean();

  const total = await Collection.countDocuments();

  res.json({
    data,
    pagination: {
      page,
      pageSize,
      total,
      totalPages: Math.ceil(total / pageSize),
    },
  });
});
```

#### 適用シーン

```markdown
✅ 適合
├─ 管理画面（注文一覧、ユーザー一覧）
├─ データ検索システム（履歴）
├─ 公開サイト（ブログ、ニュース）
└─ SEO が必要なページ

❌ 不向き
├─ スムーズなスクロール体験が必要
├─ リアルタイム更新のリスト（ページネーションが不安定になる可能性）
└─ SNS 系アプリケーション
```

---

### 2. 仮想スクロール（Virtual Scrolling）— 最高パフォーマンス

> **推奨度：4/5（推奨）**
> パフォーマンス最高。大量の固定高さデータに適合

仮想スクロールは可視領域のみレンダリングする技術で、DOM ノードを 10,000+ から 20-30 に削減し、メモリ使用量を 80% 低減します。

#### パフォーマンス比較

| 指標       | 従来のレンダリング | 仮想スクロール | 改善幅   |
| ---------- | ------------------ | -------------- | -------- |
| DOM ノード数 | 10,000+          | 20-30          | ↓ 99.7%  |
| メモリ使用量 | 150 MB           | 30 MB          | ↓ 80%    |
| 初回レンダリング | 3-5 秒        | 0.3 秒         | ↑ 90%    |
| スクロール FPS | < 20           | 55-60          | ↑ 200%   |

👉 **詳細：[仮想スクロールの完全実装 →](/docs/experience/performance/lv3-virtual-scroll)**

---

### 3. 無限スクロール（Infinite Scroll）— 連続体験

> **推奨度：3/5（検討可）**
> SNS、ニュースフィードなどの連続閲覧シーンに適合

---

### 4. Web Worker 処理（Heavy Computation）

> **推奨度：4/5（推奨）**
> 大量計算でメインスレッドをブロックしない

👉 **詳細：[Web Worker の活用 →](/docs/experience/performance/lv3-web-worker)**

---

## 意思決定フロー

```
開始：数万件のデータを表示する必要がある
    ↓
Q1: ユーザーは全データを見る必要があるか？
    ├─ いいえ → バックエンドページネーション + 検索/フィルタリング ✅
    ↓
    はい
    ↓
Q2: データの高さは固定か？
    ├─ はい → 仮想スクロール ✅
    ├─ いいえ → 動的高さ仮想スクロール（複雑）または無限スクロール ✅
    ↓
Q3: 連続閲覧体験が必要か？
    ├─ はい → 無限スクロール ✅
    ├─ いいえ → バックエンドページネーション ✅
    ↓
Q4: 大量の計算が必要か（ソート、フィルタリング）？
    ├─ はい → Web Worker + 仮想スクロール ✅
    ├─ いいえ → 仮想スクロール ✅
```

---

## 面接回答テンプレート

### 構造化回答（STAR メソッド）

**面接官：画面に数万件のデータがある場合、どう最適化しますか？**

**回答：**

> "良い質問です。方式を選ぶ前に、まず実際の要件を評価します：
>
> **1. 要件分析（30秒）**
>
> - ユーザーは全データを見る必要があるか？ほとんどの場合不要
> - データの高さは固定か？技術選択に影響する
> - ユーザーの主な操作は？閲覧、検索、特定項目の検索
>
> **2. 方式選択（1分）**
>
> シーンに応じて：
>
> - **一般的な管理画面** → バックエンドページネーション（最もシンプルで信頼性が高い）
> - **スムーズなスクロールが必要** → 仮想スクロール（最高パフォーマンス）
> - **SNS タイプ** → 無限スクロール（最高の体験）
> - **複雑な計算が必要** → Web Worker + 仮想スクロール
>
> **3. 実際のケース（1分）**
>
> 以前のプロジェクトで、3000+ 本のゲームリスト表示が必要でした。
> 仮想スクロールを選択し、最終的に：
>
> - DOM ノードが 10,000+ から 20-30 に削減（↓ 99.7%）
> - メモリ使用量 80% 低減（150MB → 30MB）
> - 初回レンダリング時間が 3-5 秒から 0.3 秒に短縮
> - スクロールの滑らかさが 60 FPS に到達
>
> **4. 補完的な最適化（30秒）**
>
> どの方式を選んでも、以下を組み合わせます：
>
> - バックエンド API 最適化（必要なフィールドのみ返却、圧縮、キャッシュ）
> - スケルトンスクリーンで読み込み体験を向上
> - デバウンス・スロットルで更新頻度を制御
> - Lighthouse などのツールで継続的にパフォーマンスを監視"

---

## 関連ノート

- [仮想スクロールの完全実装 →](/docs/experience/performance/lv3-virtual-scroll)
- [Web パフォーマンス最適化の概要 →](/docs/experience/performance)
- [Web Worker の活用 →](/docs/experience/performance/lv3-web-worker)

---

## まとめ

「数万件のデータ最適化」という問題に対して：

1. **まず要件を評価**：技術を急いで選ばない
2. **複数の方式を理解**：バックエンドページネーション、仮想スクロール、無限スクロールなど
3. **トレードオフを考慮**：パフォーマンス vs 開発コスト vs ユーザー体験
4. **継続的に最適化**：監視ツールと連携し、継続的に改善
5. **データで語る**：実際のパフォーマンスデータで最適化の効果を証明

覚えておくこと：**銀の弾丸はない。現在のシーンに最も適した方式があるだけ**。
